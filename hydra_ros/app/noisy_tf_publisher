#!/usr/bin/env python3

import numpy as np
import rclpy
from rclpy.node import Node

import tf2_ros
from geometry_msgs.msg import TransformStamped
from nav_msgs.msg import Odometry
from scipy.spatial.transform import Rotation as R


def _invert_pose(p):
    p_inv = np.zeros((4, 4))
    p_inv[:3, :3] = p[:3, :3].T
    p_inv[:3, 3] = -p[:3, :3].T @ p[:3, 3]
    p_inv[3, 3] = 1
    return p_inv


def _mat_from_pose(pose):
    pose_out = np.zeros((4, 4))
    q = [pose.orientation.x, pose.orientation.y, pose.orientation.z, pose.orientation.w]
    t = [pose.position.x, pose.position.y, pose.position.z]
    Rmat = R.from_quat(q).as_matrix()
    pose_out[:3, :3] = Rmat
    pose_out[:3, 3] = t
    pose_out[3, 3] = 1
    return pose_out


def Exp(rho, theta):
    cos = np.cos
    sin = np.sin
    norm = np.linalg.norm
    xi_hat = np.zeros((4, 4))
    theta_hat = np.array(
        [[0, -theta[2], theta[1]], [theta[2], 0, -theta[0]], [-theta[1], theta[0], 0]]
    )
    xi_hat[:3, :3] = theta_hat
    xi_hat[:3, 3] = rho
    return (
        np.eye(4)
        + xi_hat
        + (1 - cos(norm(theta))) / (norm(theta) ** 2) * xi_hat @ xi_hat
        + (norm(theta) - sin(norm(theta)))
        / (norm(theta) ** 3)
        * xi_hat
        @ xi_hat
        @ xi_hat
    )


def _calc_odom_delta(odom_old, odom_new):
    w_T_old = _mat_from_pose(odom_old.pose.pose)
    w_T_new = _mat_from_pose(odom_new.pose.pose)
    delta = _invert_pose(w_T_old) @ w_T_new
    return delta


class NoisyTransformPublisher(Node):
    """Node that republishes TFs with noise added."""

    def _get_param(self, name, default=None):
        return self.declare_parameter(name, default).get_parameter_value()

    def __init__(self):
        super().__init__("noisy_tf_publisher_node")
        self._yaw_std_dev = self._get_param("yaw_std_dev", 0.01).double_value
        self._xyz_std_dev = self._get_param("xyz_std_dev", 0.01).double_value
        self._wrong_velocity_frame = self._get_param(
            "wrong_velocity_frame", False
        ).bool_value
        self._start_from_origin = self._get_param("start_from_origin", True).bool_value
        self._parent_frame = self._get_param("parent_frame", "odom").string_value
        self._child_frame = self._get_param("child_frame", "base_link").string_value
        self._br = tf2_ros.TransformBroadcaster(self)
        self._sub = self.create_subscription(Odometry, "~/odom", self._odom_cb, 10)
        self._pub = self.create_publisher(Odometry, "noisy_odom_out", 10)
        self._last_gt_odom = None
        self._last_noisy_odom = None

    def _odom_cb(self, odom_msg):
        if self._last_gt_odom is None:
            self._last_gt_odom = odom_msg
            self._last_noisy_odom = Odometry() if self._start_from_origin else odom_msg
            return

        pose_delta = _calc_odom_delta(self._last_gt_odom, odom_msg)

        self._last_noisy_odom = self._add_odom_noise(
            self._last_noisy_odom, odom_msg, pose_delta
        )

        self._publish_noisy_transform(
            self._parent_frame,
            self._child_frame,
            odom_msg.header.stamp,
            self._last_noisy_odom.pose.pose,
        )

        self._pub.publish(self._last_noisy_odom)
        self._last_gt_odom = odom_msg

    def _publish_noisy_transform(self, fixed_frame, child_frame, time, noisy_pose):
        t = TransformStamped()
        t.header.stamp = time
        t.header.frame_id = fixed_frame
        t.child_frame_id = child_frame

        # Set position from noisy pose
        t.transform.translation.x = noisy_pose.position.x
        t.transform.translation.y = noisy_pose.position.y
        t.transform.translation.z = noisy_pose.position.z

        # Set orientation from noisy pose
        t.transform.rotation = noisy_pose.orientation

        # Broadcast the noisy transform
        self._br.sendTransform(t)

    def _add_odom_noise(self, prev_noisy_odom, cur_gt_odom, pose_delta):
        updated_odom = Odometry()
        updated_odom.header = cur_gt_odom.header

        prev_pose = _mat_from_pose(prev_noisy_odom.pose.pose)
        noisy_trans = np.random.normal(scale=self._xyz_std_dev)
        noisy_rot = [0, 0, np.random.normal(scale=self._yaw_std_dev)]
        updated_pose = prev_pose @ pose_delta @ Exp(noisy_trans, noisy_rot)
        updated_odom.pose.pose.position.x = updated_pose[0, 3]
        updated_odom.pose.pose.position.y = updated_pose[1, 3]
        updated_odom.pose.pose.position.z = updated_pose[2, 3]

        q = R.from_matrix(updated_pose[:3, :3]).as_quat()
        updated_odom.pose.pose.orientation.x = q[0]
        updated_odom.pose.pose.orientation.y = q[1]
        updated_odom.pose.pose.orientation.z = q[2]
        updated_odom.pose.pose.orientation.w = q[3]

        q_gt = [
            cur_gt_odom.pose.pose.orientation.x,
            cur_gt_odom.pose.pose.orientation.y,
            cur_gt_odom.pose.pose.orientation.z,
            cur_gt_odom.pose.pose.orientation.w,
        ]

        R_gt = R.from_quat(q_gt).as_matrix()
        R_noisy = updated_pose[:3, :3]

        vel = np.array(
            [
                cur_gt_odom.twist.twist.linear.x,
                cur_gt_odom.twist.twist.linear.y,
                cur_gt_odom.twist.twist.linear.z,
            ]
        )

        if self._wrong_velocity_frame:
            vel = (R_gt.T @ R_noisy).T @ vel

        updated_odom.twist.twist.linear.x = vel[0]
        updated_odom.twist.twist.linear.y = vel[1]
        updated_odom.twist.twist.linear.z = vel[2]
        return updated_odom


def main(args=None):
    rclpy.init()
    node = NoisyTransformPublisher()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()


if __name__ == "__main__":
    main()
